- IMPORTANT create backend with tfstate in s3 (configure locking)
exmple of how it would look like (this one does not have locking, must add it)
    provider "aws" {
  region = "us-east-1"
  profile = "mywalkup"
  default_tags {
    tags = {
      Environment = var.environment
      ManagedBy   = "Terraform"
      project = "mywalkup"
    }
  }
}

terraform {
  required_providers {
    aws = {
        source  = "hashicorp/aws"
        version = "~> 5.72.0"
    }
  }
  backend "s3" {
    bucket         = "mywalkup-terraform-state"
    key            = "dev/state"
    region         = "us-east-1"
    encrypt        = true
  }
}

- Since we're using modules, most separate their use in different folders, for example: ./prod/main.tf ./staging/main.tf ./dev/main.tf , etc (DONE)
- for s3 will be an static page content, using s3 to deliver the web page (if possible and if it's included in the free tier, use cloudfront to distribute the content) ON GOING
- ec2 will act as backend, so put it in a private network with all the configuration (sg closed.) ON GOING
- bastion host to be able to connect to private resources (you should be able to connect to it from your machine) ON GOING
- new environment called "prod" which only will have an ec2 instance, but, inside the vpc you created in dev. (use outputs + data sources for this) ON GOING
- reference here the diagram: https://app.diagrams.net/#G1IGGDCaDZBr6mJX-m2Sv6UMEKaTNdujEh#%7B%22pageId%22%3A%22pwRhRBfabi0DguxKS82O%22%7D
- outputs, why are they in the main.tf? -.- (DONE)





SECOND PART
NETWORK
  create private networks
  create IN THE PRIVATE NETWORK a RDS instance running oracle. (use random resource in terraform to create the password and store the credentials in parameter store)
    what do I mean by credentials? host, username, db name, and password.
BACKEND en ec2
  nginx -> 80 -> 8080 app
  app -> docker -> app en node con un healthcheck en el root (osea en /) que devuelve 200


THIRD PART
- finish private subnets configuration (2 subnets, nat gateway, route table, route table association for each subnet)
- create rds postgres db (HAS TO BE IN PRIVATE SUBNET BLOCKING PUBLIC ACCESS)
- move backend ec2 application to private subnet
- make use of count to create (or not) a bastion host
  - you need to be capable of connecting to the postgres db from your local machine
- use dynamic blocks to configure ingress rules for SG
- make use of terraform functions (trim, upper, contains, date, etc)


FOURTH PART
- store the db password in any place, parameter store or secrets manager.
  - this has to be automatically done, no manually. (use outputs in rds or inside the same module create a secret resources/parameter store resource)
- setup a cost budget using AWS budgets
- test connection from the bastion host and if possible from the ec2 instance.
- Create pipeline to update both, FE and BE application. (gh actions or use aws pipeline)
- create a functional lambda tf + source code.
